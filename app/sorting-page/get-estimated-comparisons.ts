const table = [
  { items: 3, comparisons: 3 },
  { items: 4, comparisons: 5 },
  { items: 5, comparisons: 7 },
  { items: 6, comparisons: 10 },
  { items: 7, comparisons: 13 },
  { items: 8, comparisons: 16 },
  { items: 9, comparisons: 19 },
  { items: 10, comparisons: 23 },
  { items: 11, comparisons: 26 },
  { items: 12, comparisons: 30 },
  { items: 13, comparisons: 34 },
  { items: 14, comparisons: 38 },
  { items: 15, comparisons: 42 },
  { items: 16, comparisons: 46 },
  { items: 17, comparisons: 50 },
  { items: 18, comparisons: 55 },
  { items: 19, comparisons: 59 },
  { items: 20, comparisons: 64 },
  { items: 21, comparisons: 68 },
  { items: 22, comparisons: 73 },
  { items: 23, comparisons: 78 },
  { items: 24, comparisons: 82 },
  { items: 25, comparisons: 87 },
  { items: 26, comparisons: 92 },
  { items: 27, comparisons: 97 },
  { items: 28, comparisons: 102 },
  { items: 29, comparisons: 106 },
  { items: 30, comparisons: 111 },
  { items: 31, comparisons: 117 },
  { items: 32, comparisons: 121 },
  { items: 33, comparisons: 127 },
  { items: 34, comparisons: 132 },
  { items: 35, comparisons: 136 },
  { items: 36, comparisons: 143 },
  { items: 37, comparisons: 148 },
  { items: 38, comparisons: 154 },
  { items: 39, comparisons: 159 }
];

export const getEstimatedComparisons = (numOfItems: number): number => {
  const resultFromTable = table.find((result) => result.items === numOfItems);
  // this table was generated by running simulated trials and is the actual average for each number of items
  if (resultFromTable) return resultFromTable.comparisons;

  // however because my code wasn't written to be efficient, it takes a while to do larger number of items
  //  so this formula approximates the average for those larger values.  It probably becomes inaccurate
  //  somewhere around 200 items (just as it isn't accurate at low numbers).
  return Math.round(1.4565 * Math.pow(numOfItems, 1.2845));
};
